#include <SFML/Graphics.hpp>
#include <fstream>
#include <cstdlib>
#include <ctime>
#include <optional>

const int SIZE = 8;
const int CELL_SIZE = 60;
const int WINDOW_SIZE = (SIZE * CELL_SIZE);
int board[SIZE][SIZE];
int selectedR = -1, selectedC = -1;
int currentPlayer = 1;

void initBoard() {
    for (int r = 0; r < SIZE; r++) {
        for (int c = 0; c < SIZE; c++) board[r][c] = 0;
    }
    for (int r = 0; r < 3; r++)
        for (int c = 0; c < SIZE; c++)
            if ((r + c) % 2 == 1) board[r][c] = 2;
    for (int r = 5; r < SIZE; r++)
        for (int c = 0; c < SIZE; c++)
            if ((r + c) % 2 == 1) board[r][c] = 1;
}

void saveBoard(const std::string& path) {
    std::ofstream f(path);
    for (int r = 0; r < SIZE; r++) {
        for (int c = 0; c < SIZE; c++) f << board[r][c] << " ";
        f << "\n";
    }
}

bool loadBoard(const std::string& path) {
    std::ifstream f(path);
    if (!f.is_open()) return false;
    for (int r = 0; r < SIZE; r++)
        for (int c = 0; c < SIZE; c++) f >> board[r][c];
    return true;
}

bool inside(int r, int c) {
    return r >= 0 && r < SIZE && c >= 0 && c < SIZE;
}

bool isValidMove(int r1, int c1, int r2, int c2, int player) {
    // 1. Check if the destination square is valid and empty
    if (!inside(r2, c2) || board[r2][c2] != 0) {
        return false;
    }

    int dr = r2 - r1; // Change in row
    int dc = c2 - c1; // Change in column
    int abs_dr = abs(dr);
    int abs_dc = abs(dc);

    // 2. Check for a standard single-step diagonal move
    if (abs_dr == 1 && abs_dc == 1) {
        // Player 1 moves up (dr = -1). Player 2 moves down (dr = 1).
        if ((player == 1 && dr == -1) || (player == 2 && dr == 1)) {
            return true;
        }
    }

    // --- Check for a diagonal jump/capture move ---
    if (abs_dr == 2 && abs_dc == 2) {
        // Player 1 moves up two rows (dr = -2). Player 2 moves down two rows (dr = 2).
        if ((player == 1 && dr == -2) || (player == 2 && dr == 2)) {
            // Calculate the position of the piece being jumped over (midpoint)
            int r_mid = r1 + dr / 2; // (r1 + r2) / 2
            int c_mid = c1 + dc / 2; // (c1 + c2) / 2

            // Determine the opponent's ID
            int opponent = (player == 1) ? 2 : 1;

            // Check if the piece in the middle is the opponent's piece
            if (board[r_mid][c_mid] == opponent) {
                return true;
            }
        }
    }

    // If none of the valid moves are met
    return false;
}

bool makeMove(int r1, int c1, int r2, int c2, int player) {
    if (board[r1][c1] == player && isValidMove(r1, c1, r2, c2, player)) {
        // Move the piece to the new location
        board[r2][c2] = player;
        board[r1][c1] = 0;

        int dr = r2 - r1;
        int dc = c2 - c1;

        // Check if the move was a jump (abs diff of 2 in both coordinates)
        if (abs(dr) == 2 && abs(dc) == 2) {
            // Calculate the position of the captured piece (midpoint)
            int r_mid = r1 + dr / 2;
            int c_mid = c1 + dc / 2;

            // Remove the captured opponent's piece
            board[r_mid][c_mid] = 0;

            // NOTE: In a full Checkers game, you'd also need logic here to:
            // 1. Check if the *same* piece can make another jump (multiple jump turn).
            // 2. Enforce mandatory jumps (if any jump is possible, the player must take it).
            // 3. Promote the piece to a King if it reaches the opposite side (r2 is the King row).
        }

        return true;
    }
    return false;
}
void aiMove() {
    std::vector<std::tuple<int, int, int, int>> moves;
    std::vector<std::tuple<int, int, int, int>> jumpMoves; // store 2-step kills

    for (int r = 0; r < SIZE; r++) {
        for (int c = 0; c < SIZE; c++) {
            if (board[r][c] == 2) { // AI piece

                // ----- Normal 1-step moves -----
                int r2_step1 = r + 1;
                for (int dc : {-1, 1}) {
                    int c2 = c + dc;
                    if (isValidMove(r, c, r2_step1, c2, 2)) {
                        moves.push_back({ r, c, r2_step1, c2 });
                    }
                }

                // ----- Jump 2-step moves (captures) -----
                int r2_step2 = r + 2;
                for (int dc : {-2, 2}) {
                    int c2 = c + dc;
                    if (isValidMove(r, c, r2_step2, c2, 2)) {
                        jumpMoves.push_back({ r, c, r2_step2, c2 });
                        moves.push_back({ r, c, r2_step2, c2 }); // also put in global list
                    }
                }
            }
        }
    }

    // No available moves
    if (moves.empty())
        return;

    // ----- If jump moves exist, AI has 60% chance to choose a jump -----
    if (!jumpMoves.empty()) {
        int chance = std::rand() % 100;  // 0â€“99

        if (chance < 50) {
            // Choose a jump move (capture)
            int idx = std::rand() % jumpMoves.size();
            auto [r1, c1, r2, c2] = jumpMoves[idx];
            makeMove(r1, c1, r2, c2, 2);
            return;
        }
    }

    // ----- Otherwise choose a random move from ALL legal moves -----
    int idx = std::rand() % moves.size();
    auto [r1, c1, r2, c2] = moves[idx];
    makeMove(r1, c1, r2, c2, 2);
}


bool hasValidMoves(int player) {
    int dr_forward = (player == 1) ? -1 : 1; // -1 for P1 (up), +1 for P2 (down)

    for (int r = 0; r < SIZE; r++) {
        for (int c = 0; c < SIZE; c++) {
            if (board[r][c] == player) {

                // --- 1. Check for 1-step move ---
                int r2_step1 = r + dr_forward;
                for (int dc : {-1, 1}) {
                    int c2 = c + dc;
                    if (isValidMove(r, c, r2_step1, c2, player)) {
                        return true;
                    }
                }

                // --- 2. Check for 2-step jump move ---
                int r2_step2 = r + (dr_forward * 2);
                for (int dc : {-2, 2}) {
                    int c2 = c + dc;
                    if (isValidMove(r, c, r2_step2, c2, player)) {
                        return true;
                    }
                }
            }
        }
    }
    return false;
}

void drawBoard(sf::RenderWindow& window) {
    sf::RectangleShape cell({ static_cast<float>(CELL_SIZE), static_cast<float>(CELL_SIZE) });

    for (int r = 0; r < SIZE; r++) {
        for (int c = 0; c < SIZE; c++) {
            if ((r + c) % 2 == 0)
                cell.setFillColor(sf::Color(240, 217, 181));
            else
                cell.setFillColor(sf::Color(181, 136, 99));

            cell.setPosition({ static_cast<float>(c * CELL_SIZE), static_cast<float>(r * CELL_SIZE) });
            window.draw(cell);
        }
    }

    if (selectedR != -1 && selectedC != -1) {
        sf::RectangleShape highlight({ static_cast<float>(CELL_SIZE), static_cast<float>(CELL_SIZE) });
        highlight.setPosition({ static_cast<float>(selectedC * CELL_SIZE), static_cast<float>(selectedR * CELL_SIZE) });
        highlight.setFillColor(sf::Color(255, 255, 0, 100));
        window.draw(highlight);

        int dr = (currentPlayer == 1) ? -1 : 1;

        // ---- NORMAL 1-STEP DIAGONAL MOVES ----
        for (int dc : {-1, 1}) {
            int r2 = selectedR + dr;
            int c2 = selectedC + dc;

            if (isValidMove(selectedR, selectedC, r2, c2, currentPlayer)) {
                sf::CircleShape dot(8.f);
                dot.setFillColor(sf::Color(0, 255, 0, 150));
                dot.setPosition({
                    static_cast<float>(c2 * CELL_SIZE + CELL_SIZE / 2 - 8),
                    static_cast<float>(r2 * CELL_SIZE + CELL_SIZE / 2 - 8)
                    });
                window.draw(dot);
            }
        }

        // ---- JUMP / CAPTURE 2-STEP DIAGONAL MOVES ----
        for (int dc : {-2, 2}) {
            int r2 = selectedR + dr * 2;
            int c2 = selectedC + dc;

            if (isValidMove(selectedR, selectedC, r2, c2, currentPlayer)) {
                sf::CircleShape dot(8.f);
                dot.setFillColor(sf::Color(0, 200, 0, 200)); // slightly brighter for jumps
                dot.setPosition({
                    static_cast<float>(c2 * CELL_SIZE + CELL_SIZE / 2 - 8),
                    static_cast<float>(r2 * CELL_SIZE + CELL_SIZE / 2 - 8)
                    });
                window.draw(dot);
            }
        }
    }

    sf::CircleShape piece(CELL_SIZE * 0.35f);
    piece.setOutlineThickness(2.f);
    piece.setOutlineColor(sf::Color::Black);

    for (int r = 0; r < SIZE; r++) {
        for (int c = 0; c < SIZE; c++) {
            if (board[r][c] == 1) {
                piece.setFillColor(sf::Color(220, 20, 20));
                piece.setPosition({ static_cast<float>(c * CELL_SIZE) + CELL_SIZE * 0.15f,
                                  static_cast<float>(r * CELL_SIZE) + CELL_SIZE * 0.15f });
                window.draw(piece);
            }
            else if (board[r][c] == 2) {
                piece.setFillColor(sf::Color(40, 40, 40)); 
                piece.setPosition({ static_cast<float>(c * CELL_SIZE) + CELL_SIZE * 0.15f,
                                  static_cast<float>(r * CELL_SIZE) + CELL_SIZE * 0.15f });
                window.draw(piece);
            }
        }
    }
}

int main()
{
    std::srand(static_cast<unsigned>(std::time(nullptr)));

    sf::RenderWindow window(sf::VideoMode({ WINDOW_SIZE, WINDOW_SIZE }), "Checkers Game");
    window.setFramerateLimit(60);

    initBoard();

    while (window.isOpen())
    {
        while (const std::optional event = window.pollEvent())
        {
            if (event->is<sf::Event::Closed>())
                window.close();

            if (const auto* mousePress = event->getIf<sf::Event::MouseButtonPressed>()) {
                if (mousePress->button == sf::Mouse::Button::Left && currentPlayer == 1) {
                    auto mousePos = sf::Mouse::getPosition(window);
                    int c = mousePos.x / CELL_SIZE;
                    int r = mousePos.y / CELL_SIZE;

                    if (inside(r, c)) {
                        if (selectedR == -1) {
                            if (board[r][c] == currentPlayer) {
                                selectedR = r;
                                selectedC = c;
                            }
                        }
                        else {
                            // Try to move
                            if (makeMove(selectedR, selectedC, r, c, currentPlayer)) {
                                selectedR = -1;
                                selectedC = -1;
                                currentPlayer = 2;
                            }
                            else if (board[r][c] == currentPlayer) {
                                selectedR = r;
                                selectedC = c;
                            }
                            else {
                                selectedR = -1;
                                selectedC = -1;
                            }
                        }
                    }
                }
            }

            if (event->is<sf::Event::KeyPressed>()) {
                const auto* keyPress = event->getIf<sf::Event::KeyPressed>();
                if (keyPress->code == sf::Keyboard::Key::S) {
                    saveBoard("checkers_save.txt");
                }
                if (keyPress->code == sf::Keyboard::Key::L) {
                    loadBoard("checkers_save.txt");
                }
                if (keyPress->code == sf::Keyboard::Key::R) {
                    initBoard();
                    currentPlayer = 1;
                    selectedR = -1;
                    selectedC = -1;
                }
            }
        }

        // AI turn
        if (currentPlayer == 2) {
            sf::sleep(sf::milliseconds(500));
            aiMove();
            currentPlayer = 1;
        }

        if (!hasValidMoves(currentPlayer)) {



        }

        window.clear();
        drawBoard(window);
        window.display();
    }
    return 0;
}
